function [x_s,u_s,t_s] = Thruster_Sim(A,B,K,t,x0)
% This simulates the controls for a given cubesate A and B matricies, the
% gain (K), timescale (t), and initial conditions x0. It outputs the states
% over time (x), inputs over time (u), and timesteps t for the control
% system. This checks the inputs u and sets them to 0 when they are not a
% positive value (thruster).

global f_t uM p

% Setting up vectors
dt = 1e-3;

t_vector = 0:dt:t;

nodes = length(t_vector);

x = zeros(12,nodes);
u = zeros(12,nodes);
dxdt = ones(12,1);

x(:,1) = x0;

% Initialize f_t, p, and uM
f_t = max(-K*x(:,1),0);
uM = zeros(12,1);   
p = zeros(12,1);  

% Marching 
i = 0;

sys = ss(A,B,eye(size(A)),zeros(size(C,1),size(B,2)));
sysd = c2d(sys,dt);
Ad = sysd.A;
Bd = sysd.B;

while (((sum(abs(dxdt)) > 0.1) && (i < nodes)) || (i < 10))

    i = i+1;

    % Calculating u from lqr then modifying using PWPF function
    u_input = max(-K*x(:,i),0);

    % Defining PWPF outputs
    Kp = 4;
    T = 0.1;
    u_on = 0.7;
    u_off = 0.4;

    u(:,i) = PWPF(u_input,dt,Kp,T,u_on,u_off);

    x(:,i+1) = Ad*

    % Calculating dxdt and marching
    % dxdt = A*x(:,i) + B*u(:,i);
    % 
    % % Using Rk4 to March
    % k1 = dxdt;
    % k2 = A*(x(:,i) + dt*k1*0.5) + B*u(:,i);
    % k3 = A*(x(:,i) + dt*k2*0.5) + B*u(:,i);
    % k4 = A*(x(:,i) + dt*k3) + B*u(:,i);
    % 
    % x(:,i+1) = x(:,i) + (dt/6)*(k1 + 2*k2 + 2*k3 + k4);


end

x_s = x(:,1:i);
u_s = u(:,1:i);
t_s = t_vector(1,1:i);

end